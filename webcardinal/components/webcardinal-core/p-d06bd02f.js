import{F as e,d as n,l as t,m as o,n as s,o as a,k as i,e as r,p as l,q as c,I as f,r as d,s as u,g as h,E as m,i as b,b as p,j as v,V as x,D as $,h as y}from"./p-0ccdfdd9.js";import{s as M,j as A,q as j,o as g,b as w,l as E,n as P,h as C,r as O,d as T,i as N,c as k}from"./p-45c37eb2.js";import{c as V,d as W}from"./p-e506992e.js";function q(e,n,t){const o=n.getChainValue(t);if(o){for(const[n,t]of Object.entries(o))M(e,{key:n,value:t});if(!0===o._saveElement){for(const n in e)"function"==typeof e[n]&&(e[n]=e[n].bind(e));o.getElement||n.setChainValue(t,Object.assign(Object.assign({},o),{getElement:()=>e}))}}if(n.hasExpression(t)){const o=n.evaluateExpression(t);for(const[n,t]of Object.entries(o))M(e,{key:n,value:t})}}function I(e){return e.nodeType===Node.ELEMENT_NODE}function B(e){return e.nodeType===Node.TEXT_NODE&&e.nodeValue&&e.nodeValue.trim()}function D(e,t,o,s=null){if(h.includes(e.nodeName.toLowerCase()))return;if(e.nodeType!==Node.TEXT_NODE||!e.nodeValue||!e.nodeValue.trim())return;const a=[...e.nodeValue.matchAll(/\{\{\s*([^\s}}]+)\s*\}\}/g)];if(!a.length)return;const i=a.map((e=>({expression:e[0],chainWithPrefix:e[1]}))).filter((({chainWithPrefix:e})=>e.startsWith(n)||e.startsWith(r))).map((e=>{let{chainWithPrefix:a}=e;const i=a.startsWith(r);let l=e.chainWithPrefix.slice(1);!i&&s&&(l=A(s,l),a=`${n}${l}`);const c=i?o:t;return Object.assign(Object.assign({},e),{chain:l,isTranslation:i,isModel:!i,isModelExpression:c.hasExpression(l),evaluateModelExpression:()=>c.evaluateExpression(l),model:c,getChainValue:()=>{let e=c.getChainValue(l);if(i&&void 0===e){const{pathname:n}=window.location,t=m();console.warn(`No translations found for skin "${t}", page "${n}" and chain "${l}"`),e=l}return e}})}));if(!i.length)return;const l=e.nodeValue,c=()=>{let n=l;i.forEach((({expression:e,getChainValue:t,isModelExpression:o,evaluateModelExpression:s})=>{let a=t();["number","boolean"].includes(typeof a)&&(a=a.toString()),!a&&o&&(a=o?s():""),n=n.replace(e,a||"")})),e.nodeValue=n};c(),i.filter((e=>e.isModel)).forEach((({model:n,chain:t,isModelExpression:o})=>{const s=()=>{c()};if(n.onChange(t,s),E(e,t,s),o){const o=()=>{c()};n.onChangeExpressionChain(t,o),P(e,t,o)}}))}const F={bindElement:(m,M={model:null,translationModel:null})=>{const{model:S,translationModel:U,chainPrefix:z,enableTranslations:G=!1,recursive:H=!1}=M;if(S){if(B(m))D(m,S,U,z);else if(I(m)){const J=m;if(window.WebCardinal.components.tags.has(J.tagName.toLowerCase()))return;if(h.includes(J.tagName.toLowerCase()))return w(J,S,n,z);if(J.hasAttribute(b)){let e;J.hasAttribute(p)&&(e=J.getAttribute(p),(null==e?void 0:e.startsWith(n))&&(e=e.slice(1)));const t=A(z,e);J[v]=()=>S.hasExpression(t)?S.evaluateExpression(t):S.toObject(t)}const K=N(J,f),L=N(J,e);if(K&&L)console.error("Cannot use both data-if and data-for attributes on the same element",J);else if(K)!function(e,t,{model:o,translationModel:s,chainPrefix:a,enableTranslations:i=!1}={model:null,translationModel:null}){let l=e.getAttribute(f);if(!l.startsWith(n))return void console.warn(`Attribute "${f}" doesn't start with the chain prefix!`);l=l.slice(1);const c=A(a,l),h=Array.from(e.children);let m,b=T(h,d);const p=T(h,u);b.length||p.length||(b=Array.from(e.childNodes)),C(e,o);const v=async n=>{let r;if(n instanceof Promise)try{r=await n}catch(e){console.error("data-if condition promise failed",e),r=!1}else r=!!n;const l=m!==r;m=r,l&&(()=>{const n=m?b:p;C(e,o),n.forEach((n=>{const r=n.cloneNode(!0);O(r),e.appendChild(r),t(r,{model:o,translationModel:s,chainPrefix:a,enableTranslations:i,recursive:!0})}))})()};if(v(o.getChainValue(c)),w(e,o,n,a),i&&w(e,s,r,a),o.hasExpression(c)){v(o.evaluateExpression(c));const n=()=>{v(o.evaluateExpression(c))};o.onChangeExpressionChain(c,n),P(e,c,n)}else{const n=()=>{v(o.getChainValue(c))};o.onChange(c,n),E(e,c,n)}}(J,F.bindElement,M);else if(L)!function(f,d,{model:u,translationModel:h,chainPrefix:m,enableTranslations:b=!1}={model:null,translationModel:null}){let p=f.getAttribute(e);if(!p.startsWith(n))return void console.warn(`Attribute "${e}" doesn't start with the chain prefix!`);p=p.slice(1);const v=A(m,p);let x=u.getChainValue(v);if(!Array.isArray(x))return void console.error(`Attribute "${e}" (${p}) must be a chain to an array in the model!`,f);let $=x.length;const y=(f.getAttribute(t)||"").split(" ").filter(String),M=y.includes(o),T=y.includes(s);let N=y.includes(a);const k=[],q=[];for(j(f,v);f.childNodes.length>0;){const e=f.childNodes[0];I(e)&&e.getAttribute("slot")===i?k.push(e):q.push(e),g(e,u),e.remove()}let B=[];const D=()=>{if(!$)return C(f,u),void k.forEach((e=>{const n=e.cloneNode(!0);O(n),f.appendChild(n),d(n,{model:u,translationModel:h,chainPrefix:m,enableTranslations:b,recursive:!0})}));if(N){const e=document.createElement(f.tagName),n=Array.prototype.slice.call(f.attributes);let o;for(;o=n.pop();)o.nodeName!==t&&e.setAttribute(o.nodeName,o.nodeValue);y.length>0&&e.setAttribute(t,y.join(" ")),f.insertAdjacentElement("afterend",e),f.remove(),f=e}x.forEach(((e,n)=>{const t=[];q.forEach((e=>{const o=e.cloneNode(!0),s=A(v,n);d(o,{model:u,translationModel:h,chainPrefix:s,enableTranslations:b,recursive:!0}),t.push(o)})),B[n]?t.forEach(((e,t)=>{document.createElement("div").appendChild(B[n][t].cloneNode(!0));const o=V(e),s=V(B[n][t]);W(o,s,B[n][t])})):(t.forEach((e=>{f.appendChild(e)})),B[n]=t)}));for(let e=$;e<B.length;e++)B[e].forEach((e=>{C(e,u),e.remove()}));B.splice($)},F=(n,t=!1)=>{Array.isArray(n)||(console.error(`Attribute "${e}" must be an array in the model!`),n=[]);const o=$!==(n=n||[]).length;if(x=n,$=x.length,T)return D(),void(M&&f.dispatchEvent(new CustomEvent(l)));(t||o)&&(C(f,u),B=[],D(),M&&f.dispatchEvent(new CustomEvent(c)))};D(),w(f,u,n,m),b&&w(f,h,r,m);const S=({targetChain:e})=>{const n=v===e;F(u.getChainValue(v),n)};if(u.onChange(v,S),E(f,v,S),u.hasExpression(v)){const e=()=>{F(u.evaluateExpression(v))};u.onChangeExpressionChain(v,e),P(f,v,e)}}(J,F.bindElement,M);else{const e=J.hasAttribute(x),t=J.hasAttribute(p);if(!J.hasAttribute($)){if(e||t){let o;if(e?o=J.getAttribute(x):(console.warn(`Attribute "${p}" is deprecated for binding! Use the "${x}" key attribute instead.`,J),o=J.getAttribute(p)),o.startsWith(n)){o=o.slice(1);const e=A(z,o);J.setAttribute(x,`${n}${e}`),t&&J.setAttribute(p,`${n}${e}`),q(J,S,e),k(J,S,e);const s=()=>q(J,S,e);if(S.onChange(e,s),E(J,o,s),S.hasExpression(e)){const n=()=>q(J,S,e);S.onChangeExpressionChain(e,n),P(J,e,n)}}else console.warn(`Invalid chain found! (chain: "${o}")!\n`,`A valid chain must start with "${n}".\n`,"target element:",J)}J.tagName.startsWith(y.toUpperCase())||w(J,S,n,z),G&&w(J,U,r,z),Array.from(J.childNodes).filter(B).forEach((e=>{D(e,S,U,z)}))}H&&Array.from(J.children).forEach((e=>{F.bindElement(e,M)}))}}}else{const e=I(m)?m.tagName.toLowerCase():"text node";console.warn(`No model found for: ${e}!`)}},bindChildNodes:(e,n)=>{Array.from(e.childNodes).forEach((e=>{F.bindElement(e,Object.assign({},n))}))}};export{F as B,I as a,B as i}